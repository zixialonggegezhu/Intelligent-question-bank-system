<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能测验 - 极速流转版</title>
    
    <!-- 依赖库 -->
    <script src="https://cdn.staticfile.net/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.staticfile.net/remixicon/3.5.0/remixicon.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        /* 基础动画 */
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s ease; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        .slide-up-enter-active { transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .slide-up-enter-from { opacity: 0; transform: translateY(20px); }

        /* 滚动条 */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #E5E7EB; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #D1D5DB; }

        /* 简答题文本域聚焦光环动画 */
        .textarea-focus { transition: all 0.3s ease; }
        .textarea-focus:focus-within { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.15); border-color: #3B82F6; }
        
        /* 括号内容变化时的微动画 */
        .bracket-anim-enter-active { transition: all 0.2s ease-out; }
        .bracket-anim-enter-from { opacity: 0; transform: scale(0.5); }
        .bracket-anim-enter-to { opacity: 1; transform: scale(1); }
    </style>
</head>
<body class="bg-gray-100 h-screen font-sans overflow-hidden">

<div id="app" class="h-full relative">

    <!-- 背景装饰 -->
    <div class="absolute inset-0 z-0 bg-white p-8 filter blur-[2px] opacity-50 pointer-events-none">
        <h1 class="text-2xl font-bold mb-4">学习任务进行中...</h1>
        <div class="space-y-4">
            <div class="h-4 bg-gray-200 rounded w-3/4"></div>
            <div class="h-4 bg-gray-200 rounded w-1/2"></div>
            <div class="h-64 bg-gray-200 rounded w-full"></div>
        </div>
    </div>

    <!-- 答题卡片容器 -->
    <div class="absolute inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 sm:p-6 transition-all">
        <div class="bg-white w-full max-w-3xl h-[85vh] sm:h-auto sm:max-h-[90vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden relative border border-gray-200">
            
            <!-- 1. 头部 (Header) -->
            <div class="px-6 py-4 border-b border-gray-100 flex justify-between items-center bg-white shrink-0 z-10">
                <div class="flex items-center gap-3">
                    <span class="text-xs font-bold px-2 py-1 rounded bg-blue-50 text-blue-600 border border-blue-100">
                        {{ typeMap[currentQuestion.type] }}
                    </span>
                    <span class="text-gray-400 text-sm">第 {{ currentIndex + 1 }}/{{ questions.length }} 题</span>
                </div>
                <!-- 连对计数器 -->
                <div v-if="streak > 1" class="flex items-center gap-1 text-orange-500 font-black italic text-lg animate-bounce">
                    <i class="ri-fire-fill"></i> {{ streak }} 连对!
                </div>
            </div>

            <!-- 2. 内容区 (Body) -->
            <div class="flex-1 overflow-y-auto custom-scroll p-6 sm:p-8 bg-gray-50/30 scroll-smooth" ref="scrollArea">
                
                <!-- 题干与实时答案回显 -->
                <div class="mb-8">
                    <div class="text-lg sm:text-xl font-bold text-gray-800 leading-relaxed select-text">
                        {{ currentQuestion.stem }}
                        
                        <!-- 题干后的括号回显 (仅针对选择/判断题) -->
                        <span v-if="['single', 'multiple', 'judge'].includes(currentQuestion.type)" 
                              class="inline-block whitespace-nowrap ml-1 text-blue-600 font-mono">
                            ( 
                            <transition name="bracket-anim" mode="out-in">
                                <span :key="stemSuffix" class="inline-block min-w-[1em] text-center">{{ stemSuffix }}</span>
                            </transition>
                            )
                        </span>
                    </div>

                    <div v-if="currentQuestion.code" class="mt-4 bg-gray-900 text-gray-200 p-4 rounded-lg text-sm font-mono overflow-x-auto">
                        <pre>{{ currentQuestion.code }}</pre>
                    </div>
                </div>

                <!-- 交互区域 -->
                <div class="space-y-4 mb-8">
                    
                    <!-- A. 单选/判断 -->
                    <template v-if="['single', 'judge'].includes(currentQuestion.type)">
                        <button v-for="(opt, idx) in currentQuestion.options" :key="idx"
                            @click="selectOption(idx)"
                            :disabled="status === 'feedback'"
                            class="w-full text-left p-4 rounded-xl border-2 flex items-start gap-3 relative transition-all duration-200"
                            :class="getOptionClass(idx)">
                            
                            <div class="flex-shrink-0 w-6 h-6 rounded-full border flex items-center justify-center text-xs font-bold mt-0.5"
                                 :class="getOptionIconClass(idx)">
                                <span v-if="!(status === 'feedback' && (userAnswer === idx || currentQuestion.correct === idx))">{{ ['A','B','C','D'][idx] }}</span>
                                <i v-else-if="currentQuestion.correct === idx" class="ri-check-line text-white"></i>
                                <i v-else class="ri-close-line text-white"></i>
                            </div>
                            <span class="text-sm sm:text-base font-medium text-gray-700">{{ opt }}</span>
                        </button>
                    </template>

                    <!-- B. 多选 -->
                    <template v-if="currentQuestion.type === 'multiple'">
                        <button v-for="(opt, idx) in currentQuestion.options" :key="idx"
                            @click="toggleOption(idx)"
                            :disabled="status === 'feedback'"
                            class="w-full text-left p-4 rounded-xl border-2 flex items-start gap-3 relative transition-all"
                            :class="getMultipleOptionClass(idx)">
                            
                            <div class="flex-shrink-0 w-6 h-6 rounded border flex items-center justify-center mt-0.5"
                                 :class="getMultipleIconClass(idx)">
                                <i v-if="userAnswer.includes(idx) || (status === 'feedback' && currentQuestion.correct.includes(idx))" class="ri-check-line text-white"></i>
                            </div>
                            <span class="text-sm sm:text-base font-medium text-gray-700">{{ opt }}</span>
                        </button>
                    </template>

                    <!-- C. 填空 -->
                    <template v-if="currentQuestion.type === 'blank'">
                        <input type="text" 
                            v-model="textAnswer"
                            :disabled="status === 'feedback'"
                            placeholder="在此输入您的答案..."
                            class="w-full p-4 text-lg border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 outline-none transition-all disabled:bg-gray-100 disabled:text-gray-500"
                            :class="{'border-red-500 bg-red-50': status === 'feedback' && !isCorrect, 'border-green-500 bg-green-50': status === 'feedback' && isCorrect}"
                        >
                    </template>

                    <!-- D. 简答题 -->
                    <template v-if="currentQuestion.type === 'essay'">
                        <div class="textarea-focus bg-white rounded-xl border-2 border-gray-300 overflow-hidden"
                             :class="{'bg-gray-50 border-gray-200': status === 'feedback'}">
                            <textarea 
                                v-model="textAnswer"
                                :disabled="status === 'feedback'"
                                rows="6"
                                placeholder="请输入您的详细回答..."
                                class="w-full p-4 text-base outline-none resize-none bg-transparent disabled:text-gray-500 placeholder-gray-400"
                            ></textarea>
                            <div class="px-4 py-2 bg-gray-50 border-t border-gray-100 text-right text-xs text-gray-400 flex justify-between items-center">
                                <span><i class="ri-markdown-line align-middle text-lg"></i> 支持简单文本</span>
                                <span>{{ textAnswer.length }} 字</span>
                            </div>
                        </div>
                    </template>

                </div>

                <!-- 3. 结果反馈区 (仅客观题提交后显示) -->
                <transition name="slide-up">
                    <div v-if="status === 'feedback'" class="bg-white rounded-xl border border-gray-100 shadow-sm overflow-hidden mb-4 ring-1 ring-black/5">
                        
                        <!-- 结果条 -->
                        <div class="px-5 py-3 flex items-center gap-2 font-bold text-white" 
                             :class="isCorrect ? 'bg-green-500' : 'bg-red-500'">
                            <i :class="isCorrect ? 'ri-emotion-happy-line' : 'ri-emotion-unhappy-line'" class="text-xl"></i>
                            <span>{{ isCorrect ? '回答正确！' : '回答错误' }}</span>
                        </div>
                        
                        <div class="p-5 sm:p-6 space-y-4">
                            <!-- 正确答案展示 -->
                            <div v-if="!isCorrect" class="flex flex-col sm:flex-row sm:items-baseline gap-2 pb-3 border-b border-gray-100">
                                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">正确答案</span>
                                <span class="text-green-600 font-bold text-lg select-all">{{ getCorrectAnswerDisplay() }}</span>
                            </div>

                            <!-- 解析 -->
                            <div v-if="currentQuestion.explanation">
                                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2 block">试题解析</span>
                                <div class="text-gray-700 text-sm leading-relaxed text-justify bg-gray-50 p-3 rounded-lg border border-gray-100">
                                    {{ currentQuestion.explanation }}
                                </div>
                            </div>
                        </div>
                    </div>
                </transition>
                
                <div class="h-16"></div>
            </div>

            <!-- 4. 底部操作栏 -->
            <div class="absolute bottom-0 left-0 right-0 p-4 sm:px-8 sm:py-5 bg-white border-t border-gray-100 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)] z-20 flex justify-end gap-3">
                <button v-if="currentIndex > 0" @click="prevQuestion" class="px-4 py-2 rounded-lg text-gray-500 hover:bg-gray-100 font-medium transition text-sm">
                    上一题
                </button>

                <!-- 提交按钮：状态不是 feedback 时显示 -->
                <button v-if="status !== 'feedback'" 
                    @click="submitAnswer" 
                    :disabled="!hasAnswered"
                    class="flex-1 sm:flex-none sm:w-40 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white px-6 py-2.5 rounded-lg font-bold shadow-lg shadow-blue-200 transition-all active:scale-95 flex items-center justify-center gap-2">
                    <span>{{ currentQuestion.type === 'essay' ? '提交' : '提交答案' }}</span>
                    <i class="ri-arrow-right-circle-line text-lg"></i>
                </button>

                <!-- 下一题按钮：状态是 feedback 时显示 (仅客观题会出现此状态) -->
                <button v-else 
                    @click="nextQuestion" 
                    class="flex-1 sm:flex-none sm:w-40 bg-gray-900 hover:bg-black text-white px-6 py-2.5 rounded-lg font-bold shadow-lg transition-all active:scale-95 flex items-center justify-center gap-2">
                    <span>下一题</span>
                    <i class="ri-skip-forward-line"></i>
                </button>
            </div>

        </div>
    </div>
</div>

<script>
    const { createApp, ref, computed, nextTick } = Vue;

    // 模拟数据 (将简答题放在最后演示)
    const MOCK_QUESTIONS = [
        {
            id: 1, type: 'single',
            stem: "在使用 Vue 3 组合式 API 时，若需要定义一个响应式的对象，应该优先使用以下哪个 API？",
            options: ["ref()", "reactive()", "computed()", "watchEffect()"],
            correct: 1,
            explanation: "reactive() 函数用于创建一个响应式对象或数组。"
        },
        {
            id: 2, type: 'multiple',
            stem: "下列关于 HTTP/2 协议特性的描述中，正确的有哪些？",
            options: ["二进制分帧", "多路复用", "头部压缩", "强制要求 HTTPS"],
            correct: [0, 1, 2],
            explanation: "HTTP/2 引入了二进制分帧层、多路复用允许在单一连接上并行传输多个请求。"
        },
        {
            id: 3, type: 'judge',
            stem: "JavaScript 中 '==' 会进行类型转换，而 '===' 不会。",
            options: ["正确", "错误"],
            correct: 0,
            explanation: "正确。'==' 是抽象相等比较，'===' 是严格相等。"
        },
        {
            id: 4, type: 'blank',
            stem: "CSS中，使flex元素垂直居中的属性是：align-items: ______;",
            options: [], 
            correct: "center",
            explanation: "align-items: center; 可以实现垂直居中。"
        },
        // 简答题
        {
            id: 5, type: 'essay',
            stem: "请简述浏览器的“同源策略”及其作用，并列举两种常见的跨域解决方案。",
            options: [],
            correct: "", 
            explanation: "同源策略是浏览器的一种安全机制，限制不同源的文档脚本交互。跨域方案包括：CORS（跨域资源共享）、JSONP、Nginx反向代理等。"
        }
    ];

    createApp({
        setup() {
            const currentIndex = ref(0);
            const status = ref('answering'); 
            const userAnswer = ref(null); 
            const textAnswer = ref('');
            const isCorrect = ref(false);
            const streak = ref(0);
            const scrollArea = ref(null);

            const questions = MOCK_QUESTIONS;
            const currentQuestion = computed(() => questions[currentIndex.value]);

            const typeMap = {
                'single': '单项选择题',
                'multiple': '多项选择题',
                'judge': '判断题',
                'blank': '填空题',
                'essay': '简答题'
            };

            const hasAnswered = computed(() => {
                const q = currentQuestion.value;
                if (q.type === 'multiple') return userAnswer.value.length > 0;
                if (q.type === 'blank' || q.type === 'essay') return textAnswer.value.trim().length > 0;
                return userAnswer.value !== null;
            });

            // 题干后的括号内容计算
            const stemSuffix = computed(() => {
                const q = currentQuestion.value;
                // 1. 填空/简答题：不显示括号回显
                if (q.type === 'blank' || q.type === 'essay') return null;

                // 2. 没答：显示空
                if (!hasAnswered.value) return ' ';

                // 3. 已答：显示选项或文字
                const labels = ['A', 'B', 'C', 'D'];
                
                if (q.type === 'single') {
                    return ` ${labels[userAnswer.value]} `;
                } 
                else if (q.type === 'multiple') {
                    // 排序并转换成字母
                    const sorted = [...userAnswer.value].sort((a,b)=>a-b).map(i => labels[i]);
                    return ` ${sorted.join(', ')} `;
                }
                else if (q.type === 'judge') {
                    // 判断题：直接显示选项文字（正确/错误）
                    return ` ${q.options[userAnswer.value]} `;
                }
                
                return ' ';
            });

            const resetState = () => {
                status.value = 'answering';
                userAnswer.value = currentQuestion.value.type === 'multiple' ? [] : null;
                textAnswer.value = '';
                isCorrect.value = false;
                if (scrollArea.value) scrollArea.value.scrollTop = 0;
            };

            const selectOption = (idx) => {
                if (status.value === 'feedback') return;
                userAnswer.value = idx;
                status.value = 'selected';
            };

            const toggleOption = (idx) => {
                if (status.value === 'feedback') return;
                const arr = userAnswer.value;
                if (arr.includes(idx)) {
                    userAnswer.value = arr.filter(i => i !== idx);
                } else {
                    userAnswer.value = [...arr, idx];
                }
                status.value = userAnswer.value.length > 0 ? 'selected' : 'answering';
            };

            const submitAnswer = () => {
                const q = currentQuestion.value;
                
                // 升级逻辑：简答题直接跳下一题
                if (q.type === 'essay') {
                    nextQuestion(); // 核心修改：直接跳转
                } else {
                    let correct = false;
                    if (q.type === 'single' || q.type === 'judge') {
                        correct = userAnswer.value === q.correct;
                    } else if (q.type === 'multiple') {
                        const userSorted = [...userAnswer.value].sort().toString();
                        const correctSorted = [...q.correct].sort().toString();
                        correct = userSorted === correctSorted;
                    } else if (q.type === 'blank') {
                        correct = textAnswer.value.trim().toLowerCase() === q.correct.toLowerCase();
                    }

                    isCorrect.value = correct;
                    status.value = 'feedback';

                    if (correct) {
                        streak.value++;
                        triggerConfetti();
                    } else {
                        streak.value = 0;
                    }
                    
                    nextTick(() => {
                        if (scrollArea.value) {
                            scrollArea.value.scrollTo({ top: scrollArea.value.scrollHeight, behavior: 'smooth' });
                        }
                    });
                }
            };

            const nextQuestion = () => {
                if (currentIndex.value < questions.length - 1) {
                    currentIndex.value++;
                    resetState();
                } else {
                    alert('已经是最后一题啦！');
                }
            };
            
            const prevQuestion = () => {
                if (currentIndex.value > 0) {
                    currentIndex.value--;
                    resetState();
                }
            };

            // 样式类生成函数
            const getOptionClass = (idx) => {
                const base = "cursor-pointer ";
                if (status.value === 'feedback') {
                    const q = currentQuestion.value;
                    if (q.correct === idx) return "bg-green-50 border-green-500 shadow-[0_0_0_1px_rgba(34,197,94,1)]";
                    if (userAnswer.value === idx && !isCorrect.value) return "bg-red-50 border-red-500 opacity-60";
                    return "border-gray-200 bg-gray-50 opacity-50 cursor-not-allowed";
                }
                if (userAnswer.value === idx) return base + "border-blue-500 bg-blue-50 shadow-[0_0_0_1px_rgba(59,130,246,1)]";
                return base + "border-gray-200 hover:border-blue-300 hover:bg-gray-50";
            };

            const getOptionIconClass = (idx) => {
                if (status.value === 'feedback') {
                    if (currentQuestion.value.correct === idx) return "bg-green-500 border-green-500 text-white";
                    if (userAnswer.value === idx && !isCorrect.value) return "bg-red-500 border-red-500 text-white";
                    return "border-gray-300 text-gray-400";
                }
                if (userAnswer.value === idx) return "bg-blue-600 border-blue-600 text-white";
                return "border-gray-300 text-gray-500 group-hover:border-blue-400 group-hover:text-blue-500";
            };

            const getMultipleOptionClass = (idx) => {
                if (status.value === 'feedback') {
                    const q = currentQuestion.value;
                    if (q.correct.includes(idx)) return "bg-green-50 border-green-500 shadow-[0_0_0_1px_rgba(34,197,94,1)]";
                    if (userAnswer.value.includes(idx) && !q.correct.includes(idx)) return "bg-red-50 border-red-500 opacity-60";
                    return "border-gray-200 bg-gray-50 opacity-50 cursor-not-allowed";
                }
                if (userAnswer.value.includes(idx)) return "cursor-pointer border-blue-500 bg-blue-50 shadow-[0_0_0_1px_rgba(59,130,246,1)]";
                return "cursor-pointer border-gray-200 hover:border-blue-300 hover:bg-gray-50";
            };

            const getMultipleIconClass = (idx) => {
                if (status.value === 'feedback') {
                     if (currentQuestion.value.correct.includes(idx)) return "bg-green-500 border-green-500";
                     if (userAnswer.value.includes(idx)) return "bg-red-500 border-red-500"; 
                     return "border-gray-300";
                }
                if (userAnswer.value.includes(idx)) return "bg-blue-600 border-blue-600";
                return "border-gray-300 bg-white group-hover:border-blue-400";
            };

            const getCorrectAnswerDisplay = () => {
                const q = currentQuestion.value;
                if (q.type === 'single' || q.type === 'judge') return q.options[q.correct];
                if (q.type === 'multiple') return q.correct.map(i => ['A','B','C','D'][i]).join('、');
                if (q.type === 'blank') return q.correct;
                return '';
            };

            const triggerConfetti = () => {
                const count = 200;
                const defaults = { origin: { y: 0.7 } };
                function fire(particleRatio, opts) {
                    confetti(Object.assign({}, defaults, opts, {
                        particleCount: Math.floor(count * particleRatio)
                    }));
                }
                fire(0.25, { spread: 26, startVelocity: 55 });
                fire(0.2, { spread: 60 });
                fire(0.35, { spread: 100, decay: 0.91, scalar: 0.8 });
                fire(0.1, { spread: 120, startVelocity: 25, decay: 0.92, scalar: 1.2 });
                fire(0.1, { spread: 120, startVelocity: 45 });
            };

            return {
                currentIndex, currentQuestion, questions, typeMap,
                status, userAnswer, textAnswer, isCorrect, streak, hasAnswered,
                scrollArea, stemSuffix,
                selectOption, toggleOption, submitAnswer, nextQuestion, prevQuestion, resetState,
                getOptionClass, getOptionIconClass, getMultipleOptionClass, getMultipleIconClass, getCorrectAnswerDisplay
            };
        }
    }).mount('#app');
</script>

</body>
</html>
